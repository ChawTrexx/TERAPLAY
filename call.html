<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ğŸ”¥ Voice Call</title>
<style>
body {
  font-family: Poppins, sans-serif;
  background: #0a0a0a;
  color: white;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  margin: 0;
}
h1 { color: #00ffae; margin-bottom: 10px; }
button {
  background: #00ffae;
  color: black;
  border: none;
  padding: 10px 25px;
  font-size: 17px;
  border-radius: 10px;
  cursor: pointer;
  margin: 10px;
}
button:hover { background: #00d48a; }
#onlineCount { margin-bottom: 20px; font-size: 18px; color: #ccc; }
#callPopup {
  display: none;
  position: fixed;
  top: 40%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #111;
  border: 2px solid #00ffae;
  padding: 25px;
  border-radius: 15px;
  text-align: center;
}
#audioSwitch { display: none; margin-top: 15px; }
</style>
</head>
<body>
<h1>ğŸ”¥ Voice Call</h1>
<div id="onlineCount">Online: 0</div>

<button id="callBtn">ğŸ“ Start Call</button>
<button id="hangupBtn" style="display:none;">âŒ Hang Up</button>

<div id="callPopup">
  <h2 id="incomingText"></h2>
  <button id="acceptBtn">âœ… Accept</button>
  <button id="rejectBtn">âŒ Reject</button>
</div>

<audio id="remoteAudio" autoplay></audio>
<div id="audioSwitch">
  <button id="toggleOutput">ğŸ”Š Speaker</button>
</div>

<!-- Firebase + WebRTC -->
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
import { getDatabase, ref, push, set, onValue, remove, onDisconnect } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyA_IGhhpYGsJDy1M9VPH-NXY561BF31mgg",
  authDomain: "wechat-eee4d.firebaseapp.com",
  databaseURL: "https://wechat-eee4d-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "wechat-eee4d",
  storageBucket: "wechat-eee4d.firebasestorage.app",
  messagingSenderId: "156838661275",
  appId: "1:156838661275:web:3d0cf4f3b402391801ca3e",
  measurementId: "G-0X6QKPRZJ3"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

const onlineRef = ref(db, "onlineUsers");
const callRef = ref(db, "calls");

const callBtn = document.getElementById("callBtn");
const hangupBtn = document.getElementById("hangupBtn");
const callPopup = document.getElementById("callPopup");
const incomingText = document.getElementById("incomingText");
const acceptBtn = document.getElementById("acceptBtn");
const rejectBtn = document.getElementById("rejectBtn");
const onlineCount = document.getElementById("onlineCount");
const remoteAudio = document.getElementById("remoteAudio");
const audioSwitch = document.getElementById("audioSwitch");
const toggleOutput = document.getElementById("toggleOutput");

let localStream;
let peerConnection;
let myId = Math.floor(Math.random() * 1000);
let currentCallKey = null;
let isSpeaker = false;

// --- ONLINE USERS TRACK ---
const me = push(onlineRef);
set(me, { id: myId });
onDisconnect(me).remove();
onValue(onlineRef, (snap) => {
  onlineCount.innerText = "Online: " + snap.size;
});

// --- CALL LOGIC ---
callBtn.onclick = async () => {
  const snapshot = await (await fetch(db._delegate._repoInfo_.url + "/onlineUsers.json")).json();
  const users = Object.values(snapshot || {});
  const others = users.filter(u => u.id !== myId);
  if (!others.length) return alert("No other users online!");

  const target = others[0];
  const newCall = push(callRef);
  currentCallKey = newCall.key;
  set(newCall, { from: myId, to: target.id, status: "calling" });
  alert("ğŸ“ Calling user " + target.id + "...");
};

// --- INCOMING CALL ---
onValue(callRef, async (snap) => {
  const calls = snap.val();
  if (!calls) return;
  for (const key in calls) {
    const call = calls[key];
    if (call.to === myId && call.status === "calling") {
      currentCallKey = key;
      incomingText.innerText = `ğŸ“² Incoming call from user ${call.from}`;
      callPopup.style.display = "block";
    } else if (call.status === "rejected" && call.from === myId) {
      alert(`âŒ User ${call.to} rejected your call`);
      remove(ref(db, "calls/" + key));
    }
  }
});

// --- ACCEPT CALL ---
acceptBtn.onclick = async () => {
  callPopup.style.display = "none";
  set(ref(db, "calls/" + currentCallKey + "/status"), "accepted");
  startCall(true);
};

// --- REJECT CALL ---
rejectBtn.onclick = () => {
  callPopup.style.display = "none";
  set(ref(db, "calls/" + currentCallKey + "/status"), "rejected");
};

// --- WEBRTC CONNECTION ---
async function startCall(isReceiver) {
  localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  peerConnection = new RTCPeerConnection();
  localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

  peerConnection.ontrack = (event) => {
    remoteAudio.srcObject = event.streams[0];
    showAudioSwitch();
  };

  peerConnection.onicecandidate = async (event) => {
    if (event.candidate) {
      set(ref(db, "calls/" + currentCallKey + "/candidate_" + myId), event.candidate.toJSON());
    }
  };

  const callDataRef = ref(db, "calls/" + currentCallKey);
  onValue(callDataRef, async (snap) => {
    const data = snap.val();
    if (data?.offer && !isReceiver) {
      await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      set(ref(db, "calls/" + currentCallKey + "/answer"), answer);
    } else if (data?.answer && isReceiver) {
      await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
    } else if (data?.["candidate_" + (isReceiver ? data.from : data.to)]) {
      try {
        await peerConnection.addIceCandidate(new RTCIceCandidate(data["candidate_" + (isReceiver ? data.from : data.to)]));
      } catch (err) {
        console.error(err);
      }
    }
  });

  if (!isReceiver) {
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    set(ref(db, "calls/" + currentCallKey + "/offer"), offer);
  }

  callBtn.style.display = "none";
  hangupBtn.style.display = "block";
}

// --- HANGUP ---
hangupBtn.onclick = () => {
  peerConnection.close();
  peerConnection = null;
  remove(ref(db, "calls/" + currentCallKey));
  callBtn.style.display = "block";
  hangupBtn.style.display = "none";
  audioSwitch.style.display = "none";
};

// --- AUDIO OUTPUT SWITCH ---
function showAudioSwitch() {
  audioSwitch.style.display = "block";
}

toggleOutput.onclick = async () => {
  if (!remoteAudio.sinkId) {
    alert("Your browser doesn't support manual output switching.");
    return;
  }

  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const audioOutputs = devices.filter(d => d.kind === "audiooutput");
    if (audioOutputs.length < 2) {
      alert("No alternate audio output found.");
      return;
    }

    isSpeaker = !isSpeaker;
    const targetDevice = audioOutputs[isSpeaker ? 1 : 0];
    await remoteAudio.setSinkId(targetDevice.deviceId);
    toggleOutput.textContent = isSpeaker ? "ğŸ§ Earpiece" : "ğŸ”Š Speaker";
  } catch (err) {
    console.error(err);
    alert("Switching audio output failed.");
  }
};
</script>
</body>
</html>
